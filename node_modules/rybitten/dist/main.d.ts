import { ColorCoords } from './cubes';

interface Blerp {
    (a00: number, a01: number, a10: number, a11: number, tx: number, ty: number): number;
}
interface Trilerp {
    (a000: number, a010: number, a100: number, a110: number, a001: number, a011: number, a101: number, a111: number, tx: number, ty: number, tz: number): number;
}
/**
 * Applies smoothstep smoothing to a value, creating an S-curve.
 * The function interpolates smoothly between 0 and 1 using the formula: t * t * (3 - 2 * t)
 * Also known as "Smootherstep" or "Ken Perlin's smoothstep"
 *
 * @param t - Input value between 0 and 1
 * @returns Smoothed value between 0 and 1
 * @see {@link https://en.wikipedia.org/wiki/Smoothstep#Smootherstep|Smoothstep on Wikipedia}
 *
 * @example
 * easingSmoothstep(0.5); // returns 0.5
 * easingSmoothstep(0.1); // returns 0.028
 * easingSmoothstep(0.9); // returns 0.972
 */
export declare const easingSmoothstep: (t: number) => number;
/**
 * Performs linear interpolation between two values.
 * Returns the value at position t between a and b, where t is between 0 and 1.
 *
 * @param a - Start value
 * @param b - End value
 * @param t - Interpolation factor (0 to 1)
 * @returns Interpolated value: a + t * (b - a)
 *
 * @example
 * lerp(0, 100, 0.5);  // returns 50
 * lerp(20, 80, 0.25); // returns 35
 * lerp(-10, 10, 0.1); // returns -8
 */
export declare const lerp: (a: number, b: number, t: number) => number;
/**
 * Performs bilinear interpolation between four points in a 2D space.
 * Useful for interpolating values on a rectangular grid.
 *
 * @param a00 - Value at coordinate (0,0)
 * @param a01 - Value at coordinate (0,1)
 * @param a10 - Value at coordinate (1,0)
 * @param a11 - Value at coordinate (1,1)
 * @param tx - Interpolation factor along x-axis (0 to 1)
 * @param ty - Interpolation factor along y-axis (0 to 1)
 * @returns Interpolated value
 *
 * @example
 * // Interpolate between four corners of a unit square
 * blerp(0, 1, 1, 2, 0.5, 0.5); // returns the center value
 */
export declare const blerp: Blerp;
/**
 * Performs trilinear interpolation between eight values in a 3D space.
 * Based on Culori's implementation (MIT License)
 * MIT License Culori
 *
 * @param a000 - Value at coordinate (0,0,0)
 * @param a010 - Value at coordinate (0,1,0)
 * @param a100 - Value at coordinate (1,0,0)
 * @param a110 - Value at coordinate (1,1,0)
 * @param a001 - Value at coordinate (0,0,1)
 * @param a011 - Value at coordinate (0,1,1)
 * @param a101 - Value at coordinate (1,0,1)
 * @param a111 - Value at coordinate (1,1,1)
 * @param tx - Interpolation factor along x-axis (0 to 1)
 * @param ty - Interpolation factor along y-axis (0 to 1)
 * @param tz - Interpolation factor along z-axis (0 to 1)
 * @returns Interpolated value
 * @see {@link https://github.com/Evercoder/culori/blob/40a09603b46d0ac3ead4eb16cb51405635bdcf12/src/interpolate/lerp.js#L8|Culori Source}
 */
export declare const trilerp: Trilerp;
/**
 * Converts RYB color coordinates to RGB color space
 * @param coords - Array of [red, yellow, blue] values between 0 and 1
 * @param options - Configuration options
 * @param options.cube - Color cube for conversion (defaults to RYB_ITTEN)
 * @param options.easingFn - Easing function for color interpolation
 * @returns Array of [red, green, blue] values between 0 and 1
 */
export declare function ryb2rgb(coords: ColorCoords, { cube, easingFn }?: {
    cube?: import('./cubes').ColorCube | undefined;
    easingFn?: ((t: number) => number) | undefined;
}): ColorCoords;
/**
 * Converts HSL (Hue, Saturation, Lightness) color values to RGB color space.
 * Adapted from Culori (MIT License)
 *
 * @param hsl - Array of [hue, saturation, lightness]
 * @param hsl[0] - Hue value in degrees (0-360)
 * @param hsl[1] - Saturation value (0-1)
 * @param hsl[2] - Lightness value (0-1)
 * @returns Array of [red, green, blue] values, each between 0 and 1
 *
 * @example
 * hslToRgb([0, 1, 0.5]);    // returns [1, 0, 0] (red)
 * hslToRgb([120, 1, 0.5]);  // returns [0, 1, 0] (green)
 * hslToRgb([240, 1, 0.5]);  // returns [0, 0, 1] (blue)
 * hslToRgb([0, 0, 0.5]);    // returns [0.5, 0.5, 0.5] (gray)
 *
 * @see {@link https://github.com/Evercoder/culori/|Culori Source}
 */
export declare function hslToRgb(hsl: ColorCoords): ColorCoords;
/**
 * Converts a color from RYB-HSL color space to RGB color space.
 * Combines HSL to RGB conversion with RYB to RGB mapping using a color cube.
 *
 * @param hsl - Array of [hue, saturation, lightness]
 * @param hsl[0] - Hue value in degrees (0-360)
 * @param hsl[1] - Saturation value (0-1)
 * @param hsl[2] - Lightness value (0-1)
 * @param options - Configuration options
 * @param [options.cube=RYB_ITTEN] - Color cube for RYB to RGB mapping
 * @param [options.easingFn=easingSmoothstep] - Easing function for color interpolation
 * @param [options.invertLightness=true] - Whether to invert the lightness value
 * @returns Array of [red, green, blue] values, each between 0 and 1
 *
 * @example
 * // Convert RYB HSL red to RGB
 * rybHsl2rgb([0, 1, 0.5]); // Returns RGB values
 *
 * // Using custom options
 * rybHsl2rgb([120, 1, 0.5], {
 *   invertLightness: false,
 *   cube: customCube,
 *   easingFn: customEasing
 * });
 */
export declare function rybHsl2rgb(hsl: ColorCoords, { cube, easingFn, invertLightness, }?: {
    cube?: import('./cubes').ColorCube | undefined;
    easingFn?: ((t: number) => number) | undefined;
    invertLightness?: boolean | undefined;
}): ColorCoords;
export {};
