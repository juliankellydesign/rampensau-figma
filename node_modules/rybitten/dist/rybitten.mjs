import { RYB_ITTEN as f } from "./cubes.mjs";
const g = (t) => t * t * (3 - 2 * t), l = (t, n, s) => t + s * (n - t), m = (t, n, s, e, r, o) => l(l(t, n, r), l(s, e, r), o), p = (t, n, s, e, r, o, c, u, b, a, i) => l(
  m(t, n, s, e, b, a),
  m(r, o, c, u, b, a),
  i
);
function k(t, { cube: n = f, easingFn: s = g } = {}) {
  const e = s(t[0]), r = s(t[1]), o = s(t[2]), c = n.map((a) => a[0]), u = n.map((a) => a[1]), b = n.map((a) => a[2]);
  return [
    p(...c, e, r, o),
    p(...u, e, r, o),
    p(...b, e, r, o)
  ];
}
function h(t) {
  return (t % 360 + 360) % 360;
}
function T(t) {
  let [n, s, e] = t;
  n = h(n || 0);
  let r = e + s * (e < 0.5 ? e : 1 - e), o = r - (r - e) * 2 * Math.abs(n / 60 % 2 - 1), c;
  switch (Math.floor(n / 60)) {
    case 0:
      c = [r, o, 2 * e - r];
      break;
    case 1:
      c = [o, r, 2 * e - r];
      break;
    case 2:
      c = [2 * e - r, r, o];
      break;
    case 3:
      c = [2 * e - r, o, r];
      break;
    case 4:
      c = [o, 2 * e - r, r];
      break;
    case 5:
      c = [r, 2 * e - r, o];
      break;
    default:
      c = [2 * e - r, 2 * e - r, 2 * e - r];
  }
  return c;
}
function M(t, {
  cube: n = f,
  easingFn: s = g,
  invertLightness: e = !0
} = {}) {
  const r = e ? 1 - t[2] : t[2], o = T([t[0], t[1], r]);
  return k(o, { cube: n, easingFn: s });
}
export {
  m as blerp,
  g as easingSmoothstep,
  T as hslToRgb,
  l as lerp,
  k as ryb2rgb,
  M as rybHsl2rgb,
  p as trilerp
};
